[{"title":"","date":"2017-03-31T10:55:19.000Z","path":"2017/03/31/HTML的body中替换图片链接/","text":"title: HTML的body中替换图片链接 -(void)replaceDetailImageWithArticle:(LPNewsArticleModel *)article{ ​ NSMutableString body = [NSMutableString stringWithString:article.body];​ for (LPNewsDetailImgeInfo image in article.img) {​ NSString *replaceString = [NSString stringWithFormat:@”“,image.src,image.alt?image.alt:@””];​ [body replaceOccurrencesOfString:image.ref withString:replaceString options:NSCaseInsensitiveSearch range:NSMakeRange(0, body.length)];​ }​ article.body = [body copy]; }","tags":[]},{"title":"重写description，按自己的想法来NSLog","date":"2017-03-29T06:32:28.000Z","path":"2017/03/29/重写description按自己的想法来NSLog/","text":"Objective-C运行时定义了几种重要的类型。Class：定义Objective-C类 Ivar：定义对象的实例变量，包括类型和名字。 Protocol：定义正式协议。 objc_property_t：定义属性。叫这个名字可能是为了防止和Objective-C 1.0中的用户类型冲突，那时候还没有属性。 Method：定义对象方法或类方法。这个类型提供了方法的名字（就是选择器）、参数数量和类型，以及返回值（这些信息合起来称为方法的签名），还有一个指向代码的函数指针（也就是方法的实现）。 SEL：定义选择器。选择器是方法名的唯一标识符。 IMP：定义方法实现。这只是一个指向某个函数的指针，该函数接受一个对象、一个选择器和一个可变长参数列表（varargs），返回一个对象 @property 和 Ivar 的区别@property属性其实是对成员变量的一种封装。 我们先大概这样理解： @property = Ivar + setter + getterIvar Ivar可以理解为类中的一个变量，主要作用是用来保存数据的。 我们不妨来看个例子，通过下边的例子能够很清楚的解释这两个东东： 我们新建一个Person类? @interface Person : NSObject { NSString *name0; } @property(nonatomic,copy)NSString *name1; @end @implementation Person - (instancetype)init { if (self = [super init]) { } return self; } @end 在这个Person中name0就是成员变量，name1就是属性。 我们创建一个Person： 12345Person *p= [[Person alloc] init];p.name1 = @&quot;abc&quot;;NSLog(@&quot;%@&quot;,p.name1); 我们会发现，我在Person类外边是不能访问name0的，这说明了什么？这说明成员变量name0只能在它自己的类的内部被访问。 因此，我们推断出，@property其实也带有接口属性，也就是能够被外部对象访问。 p.name1 = @”abc”;这行代码其实是调用了Person中name1的setter方法。 NSLog(@”%@”,p.name1); 这行代码其实是调用了Person中name1的getter方法。 再说说setter和getter方法。大家应该都知道oc中有着严格的命名规范，拿这个例子来说，根据name1自动生成了 123-(void)setName1:(NSString *)name1&#123;&#125;- (NSString *)name1 注意：这里并不讨论MRC的情况，一切解释的前提都是在ARC下。 @synthesize 这个关键字用来指定成员变量 我们在Person的实现中，把代码改成这样： 1234567891011121314151617@implementation Person@synthesize name1 = _name2;- (instancetype)init &#123;if (self = [super init]) &#123;_name2 = @&quot;aaa&quot;;&#125;return self;&#125;@end 这样我们就指定了name1的成员变量为_name2了，我们在Person的初始化init方法中根本打不出_name1这个属性。 Person *p= [[Person alloc] init]; // p.name1 = @”abc”; NSLog(@”%@”,p.name1);我们注释掉赋值的那一行，可以看到打印结果为：aaa。 废话不多说，直接上代码123456789101112131415161718192021222324252627-(NSString *)description&#123;unsigned int count = 0;Ivar *ivars = class_copyIvarList(self.class, &amp;count);NSMutableString *str = [NSMutableString string];for (int i = 0; i &lt; count; ++i) &#123;Ivar ivar = ivars[i];const char *name = ivar_getName(ivar);NSString *proName = [NSString stringWithUTF8String:name];id value = [self valueForKey:proName];[str appendFormat:@&quot;&lt;%@ : %@&gt; \\n&quot;, proName, value];&#125;free(ivars);return str;&#125;","tags":[]},{"title":"iOS10后方法AVCaptureDeviceDiscoverySession使用","date":"2017-03-28T00:58:52.000Z","path":"2017/03/28/iOS 10后方法AVCaptureDeviceDiscoverySession使用/","text":"前言最近使用视频库，遇到一个尴尬的问题iOS 10 以前//用来返回是前置摄像头还是后置摄像头123456789101112- (AVCaptureDevice *)cameraWithPostion:(AVCaptureDevicePosition)position&#123; //返回和视频录制相关的默认设备 NSArray *devices = [AVCaptureDevice devicesWithMediaType:AVMediaTypeVideo]; //遍历这些设备返回跟postion相关的设备 for (AVCaptureDevice *device in devices) &#123; if ([device position] == position) &#123; return device; &#125; &#125; return nil;&#125; iOS10 之后1234567891011- (AVCaptureDevice *)cameraWithPostion:(AVCaptureDevicePosition)position&#123; AVCaptureDeviceDiscoverySession *devicesIOS10 = [AVCaptureDeviceDiscoverySession discoverySessionWithDeviceTypes:@[AVCaptureDeviceTypeBuiltInWideAngleCamera] mediaType:AVMediaTypeVideo position]; NSArray *devicesIOS = devicesIOS10.devices; for (AVCaptureDevice *device in devicesIOS) &#123; if ([device position] == position) &#123; return device; &#125; &#125; return nil;&#125;","tags":[]}]